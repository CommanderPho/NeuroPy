"""
This type stub file was generated by pyright.
"""

from typing import Optional, Tuple
from nptyping import NDArray
from neuropy.utils.mixins.AttrsClassHelpers import AttrsBasedClassHelperMixin, custom_define
from neuropy.utils.mixins.HDF5_representable import HDF_SerializationMixin

def find_minimum_time_bin_duration(epoch_durations: NDArray) -> float:
    """ determines the minimum time bin size that can be used to bin epochs with the provided durations.
    2024-01-25 - Used to require that the epoch was divisible into at least two bins. With my updated code it can handle the case where it's divisible into a single bin.
    
    Usage:
        from neuropy.utils.mixins.binning_helpers import find_minimum_time_bin_duration
        min_possible_time_bin_size: float = find_minimum_time_bin_duration(global_replays['duration'].to_numpy())
        min_possible_time_bin_size
    """
    ...

def get_bin_centers(bin_edges):
    """ For a series of 1D bin edges given by bin_edges, returns the center of the bins. Output will have one less element than bin_edges. """
    ...

def get_bin_edges(bin_centers): # -> NDArray[Any]:
    """ For a series of 1D bin centers given by bin_centers, returns the edges of the bins. Output will have one more element than bin_centers
        Reciprocal of get_bin_centers(bin_edges)
    """
    ...

@custom_define(slots=False, repr=False, eq=False)
class BinningInfo(HDF_SerializationMixin, AttrsBasedClassHelperMixin):
    """ Factored out of pyphocorehelpers.indexing_helpers.BinningInfo
    
    2024-08-07: refactored from `dataclass` to attrs
    
    Removed `bin_indicies`
    
    Usage:
        from neuropy.utils.mixins.binning_helpers import BinningInfo, BinningContainer
    
    """
    variable_extents: Tuple = ...
    step: float = ...
    num_bins: int = ...
    bin_indicies: NDArray = ...
    def __attrs_post_init__(self): # -> None:
        """ validate and build bin_indicies """
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class BinningContainer:
    """A container that allows accessing either bin_edges (self.edges) or bin_centers (self.centers) 
    Factored out of pyphocorehelpers.indexing_helpers.BinningContainer
    
    #TODO 2024-08-07 16:12: - [ ] Observing inconsistent values:
        a_time_bin_container: neuropy.utils.mixins.binning_helpers.BinningContainer
        │   ├── edges: numpy.ndarray  = [678.314 678.315 678.316 678.317 678.318 678.319 678.32 678.321 678.322 678.323 678.324 678.325 678.326 678.327 678.328 678.329 678.33 678.331 678.332 678.333 678.334 678.335 678.336 678.337 678.338 678.339 678.34 678.341 678.342 678.343 678.344 678.345 678.346 678.347 678.348... - (283,)
        │   ├── centers: numpy.ndarray  = [678.314] - (1,)
        │   ├── edge_info: neuropy.utils.mixins.binning_helpers.BinningInfo  = BinningInfo(variable_extents=[678.3138549999567, 678.59585499995], step=0.0009999999999763531, num_bins=283, bin_indicies=array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29...
            │   ├── variable_extents: list  = [678.3138549999567, 678.59585499995] - (2,)
            │   ├── step: numpy.float64  = 0.0009999999999763531
            │   ├── num_bins: int  = 283
            │   ├── bin_indicies: numpy.ndarray  = [  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68 ... - (283,)
        │   ├── center_info: neuropy.utils.mixins.binning_helpers.BinningInfo  = BinningInfo(variable_extents=array([678.314, 678.315, 678.316, 678.317, 678.318, 678.319, 678.32, 678.321, 678.322, 678.323, 678.324, 678.325, 678.326, 678.327, 678.328, 678.329, 678.33, 678.331, 678.332, 678.333, 678.334, 678.335, 678.336, 678.337, 678.338, 678.339, 678.34, 6...
            │   ├── variable_extents: numpy.ndarray  = [678.314 678.315 678.316 678.317 678.318 678.319 678.32 678.321 678.322 678.323 678.324 678.325 678.326 678.327 678.328 678.329 678.33 678.331 678.332 678.333 678.334 678.335 678.336 678.337 678.338 678.339 678.34 678.341 678.342 678.343 678.344 678.345 678.346 678.347 678.348... - (283,)
            │   ├── step: float  = 0.0009999999999763531
            │   ├── num_bins: int  = 1
            │   ├── bin_indicies: numpy.ndarray  = [0] - (1,)
        

    Observations:
        clearly initialized from edges, since edge_info.variable_extents is correct and center_info.variable_extents is so messed up. I didn't know it could get that way!
    

    """
    edges: NDArray
    centers: NDArray
    edge_info: BinningInfo
    center_info: BinningInfo
    @property
    def num_bins(self) -> int:
        ...
    
    def __init__(self, edges: Optional[NDArray] = ..., centers: Optional[NDArray] = ..., edge_info: Optional[BinningInfo] = ..., center_info: Optional[BinningInfo] = ...) -> None:
        ...
    
    @classmethod
    def build_edge_binning_info(cls, edges: NDArray): # -> BinningInfo:
        ...
    
    @classmethod
    def build_center_binning_info(cls, centers: NDArray, variable_extents): # -> BinningInfo:
        ...
    
    @classmethod
    def init_from_edges(cls, edges: NDArray, edge_info: Optional[BinningInfo] = ...) -> BinningContainer:
        """ initializes from edges, overwritting everything else
        """
        ...
    


def compute_spanning_bins(variable_values, num_bins: int = ..., bin_size: float = ..., variable_start_value: float = ..., variable_end_value: float = ...) -> Tuple[NDArray, BinningInfo]:
    """Extracted from pyphocorehelpers.indexing_helpers import compute_position_grid_size for use in BaseDataSessionFormats


    Args:
        variable_values ([type]): The variables to be binned, used to determine the start and end edges of the returned bins.
        num_bins (int, optional): The total number of bins to create. Defaults to None.
        bin_size (float, optional): The size of each bin. Defaults to None.
        variable_start_value (float, optional): The minimum value of the binned variable. If specified, overrides the lower binned limit instead of computing it from variable_values. Defaults to None.
        variable_end_value (float, optional): The maximum value of the binned variable. If specified, overrides the upper binned limit instead of computing it from variable_values. Defaults to None.
        debug_print (bool, optional): Whether to print debug messages. Defaults to False.

    Raises:
        ValueError: [description]

    Returns:
        np.array<float>: The computed bins
        BinningInfo: information about how the binning was performed
        
    Usage:
        ## Binning with Fixed Number of Bins:    
        xbin_edges, xbin_edges_binning_info = compute_spanning_bins(pos_df.x.to_numpy(), bin_size=active_config.computation_config.grid_bin[0]) # bin_size mode
        print(xbin_edges_binning_info)
        ## Binning with Fixed Bin Sizes:
        xbin_edges_edges, xbin_edges_binning_info = compute_spanning_bins(pos_df.x.to_numpy(), num_bins=num_bins) # num_bins mode
        print(xbin_edges_binning_info)
        
    """
    ...

def build_spanning_grid_matrix(x_values, y_values, debug_print=...): # -> tuple[NDArray[Any], list[tuple[Any, ...]], tuple[int, int]]:
    """ builds a 2D matrix with entries spanning x_values across axis 0 and spanning y_values across axis 1.
        
        For example, used to build a grid of position points from xbins and ybins.
    Usage:
        from neuropy.utils.mixins.binning_helpers import build_spanning_grid_matrix
        all_positions_matrix, flat_all_positions_matrix, original_data_shape = build_all_positions_matrix(active_one_step_decoder.xbin_centers, active_one_step_decoder.ybin_centers)
    
    Outputs:
        all_positions_matrix: a 3D matrix # .shape # (num_cols, num_rows, 2)
        flat_all_positions_matrix: a list of 2-tuples of length num_rows * num_cols
        original_data_shape: a tuple containing the shape of the original data (num_cols, num_rows)
    """
    ...

class BinnedPositionsMixin:
    """ Adds common accessors for convenince properties such as *bin_centers/*bin_labels
    
    Requires (Implementor Must Provide):
        self.ndim
        self.xbin
        self.ybin
    
    Provides:
        Provided Properties:
            xbin_centers
            ybin_centers
            xbin_labels
            ybin_labels
            dims_coord_tuple
        
    """
    @property
    def xbin_centers(self) -> NDArray:
        """ the x-position of the centers of each xbin. Note that there is (n_xbins - 1) of these. """
        ...
    
    @property
    def ybin_centers(self) -> Optional[NDArray]:
        """ the y-position of the centers of each xbin. Note that there is (n_ybins - 1) of these. """
        ...
    
    @property
    def xbin_labels(self) -> NDArray:
        """ the labels of each xbin center. Starts at 1!"""
        ...
    
    @property
    def ybin_labels(self) -> Optional[NDArray]:
        """ the labels of each ybin center. Starts at 1!"""
        ...
    
    @property
    def n_xbin_edges(self) -> int:
        """ the number of xbin edges. """
        ...
    
    @property
    def n_ybin_edges(self) -> Optional[int]:
        """ the number of ybin edges. """
        ...
    
    @property
    def n_xbin_centers(self) -> int:
        """ the number of xbin (centers). Note that there is (n_xbin_edges - 1) of these. """
        ...
    
    @property
    def n_ybin_centers(self) -> Optional[int]:
        """ the number of ybin (centers). Note that there is (n_ybin_edges - 1) of these. """
        ...
    
    @property
    def dims_coord_tuple(self): # -> tuple[int, int] | tuple[int]:
        """Returns a tuple containing the number of bins in each dimension. For 1D it will be (n_xbins,) for 2D (n_xbins, n_ybins) 
        TODO 2023-03-08 19:31: - [ ] Add to parent class (PfND) since it should have the same implementation.
        """
        ...
    


def bin_pos_nD(x: NDArray, y: NDArray, num_bins=..., bin_size=...): # -> tuple[Any | NDArray[Any], Any | NDArray[Any] | None, dict[str, Any]]:
    """ Spatially bins the provided x and y vectors into position bins based on either the specified num_bins or the specified bin_size
        Usage:
            ## Binning with Fixed Number of Bins:    
            xbin, ybin, bin_info = _bin_pos(pos_df.x.to_numpy(), pos_df.y.to_numpy(), bin_size=active_config.computation_config.grid_bin) # bin_size mode
            print(bin_info)
            ## Binning with Fixed Bin Sizes:
            xbin, ybin, bin_info = _bin_pos(pos_df.x.to_numpy(), pos_df.y.to_numpy(), num_bins=num_bins) # num_bins mode
            print(bin_info)
            
            
        TODO: 2022-04-22 - Note that I discovered that the bins generated here might cause an error when used with Pandas .cut function, which does not include the left (most minimum) values by default. This would cause the minimumal values not to be included.
        2022-07-20 - Extracted from PfND
        
        
        """
    ...

def build_df_discretized_binned_position_columns(active_df, bin_values=..., position_column_names=..., binned_column_names=..., active_computation_config=..., force_recompute=..., debug_print=...): # -> tuple[Any, list[Any], dict[str, Any]]:
    """ Adds the columns specified in binned_column_names (e.g. ('binned_x', 'binned_y') columns to the passed-in dataframe
    Requires that the passed in dataframe has at least the 'x' column (1D) and optionally the 'y' column.
    Works for both position_df and spikes_df
    
    Should work for n-dimensional data
    
    Inputs:
        active_df: the dataframe to use
        bin_values: a tuple of independent np.arrays (e.g. (xbin_values, ybin_values)) specifying the complete bin_edges for both the x and y position spaces. If not provided, active_computation_config will be used to compute appropriate ones.
        position_column_names: a tuple of the independent position column names to be binned
        binned_column_names: a tuple of the output binned column names that will be added to the dataframe
        force_recompute: if True, the columns with names binned_column_names will be overwritten even if they already exist.
        
    Usage:
        active_df, (xbin, ybin), bin_infos = build_df_discretized_binned_position_columns(active_pf_2D.filtered_spikes_df.copy(), bin_values=(active_pf_2D.xbin, active_pf_2D.ybin), active_computation_config=active_computation_config, force_recompute=False, debug_print=True)
        active_df
    
    ## TODO: Move into perminant location and replace duplicated/specific implementations with this more general version.
        Known Reimplementations:
            neuropy.analyses.time_dependent_placefields.__init__(...)
            General.Decoder.decoder_result.py - build_position_df_discretized_binned_positions(...)
    """
    ...

def transition_matrix(state_sequence, markov_order: int = ..., max_state_index: int = ..., nan_entries_replace_value: Optional[float] = ..., should_validate_normalization: bool = ...): # -> tuple[Any, Any | NDArray[Any] | float | generic | bool | int | complex | str | bytes | memoryview[int]]:
    """" Computes the transition matrix from Markov chain sequence of order `n`.
    See https://stackoverflow.com/questions/58048810/building-n-th-order-markovian-transition-matrix-from-a-given-sequence

    :param state_sequence: Discrete Markov chain state sequence in discrete time with states in 0, ..., N
    :param markov_order: Transition order

    :return: Transition matrix

    Usage:
        from neuropy.utils.mixins.binning_helpers import transition_matrix

        pf1D = deepcopy(curr_active_pipeline.computation_results['maze1'].computed_data['pf1D'])
        num_position_states = len(pf1D.xbin_labels)
        binned_x = pf1D.filtered_pos_df['binned_x'].to_numpy()
        binned_x_indicies = binned_x - 1
        binned_x_transition_matrix = transition_matrix(deepcopy(binned_x_indicies), markov_order=1, max_state_index=num_position_states)
        binned_x_transition_matrix_higher_order_list = [binned_x_transition_matrix, transition_matrix(deepcopy(binned_x_indicies), markov_order=2, max_state_index=num_position_states), transition_matrix(deepcopy(binned_x_indicies), markov_order=3, max_state_index=num_position_states)]

        ## Old method without using markov_order parameter:
        binned_x_transition_matrix[np.isnan(binned_x_transition_matrix)] = 0.0
        binned_x_transition_matrix_higher_order_list = [binned_x_transition_matrix, np.linalg.matrix_power(binned_x_transition_matrix, 2), np.linalg.matrix_power(binned_x_transition_matrix, 3)]

        ## Visualize Result:
        from pyphoplacecellanalysis.GUI.PyQtPlot.BinnedImageRenderingWindow import BasicBinnedImageRenderingWindow, LayoutScrollability
        out = BasicBinnedImageRenderingWindow(binned_x_transition_matrix, pf1D.xbin_labels, pf1D.xbin_labels, name='binned_x_transition_matrix', title="Transition Matrix for binned x (from, to)", variable_label='Transition Matrix', scrollability_mode=LayoutScrollability.NON_SCROLLABLE)

        ## print the entries in the transition matrix:
        for row in binned_x_transition_matrix: print(' '.join(f'{x:.2f}' for x in row))


    TODO 2023-03-08 13:49: - [ ] 2D Placefield Position Transition Matrix
        pf2D = deepcopy(curr_active_pipeline.computation_results['maze1'].computed_data['pf2D'])
        # try to get the position sizes for the 2D placefields:
        original_position_data_shape = np.shape(pf2D.occupancy) # (63, 16)
        flat_position_size = np.shape(np.reshape(deepcopy(pf2D.occupancy), (-1, 1)))[0] # 1008
        print(f'{original_position_data_shape = }, {flat_position_size = }')
        num_position_states = int(float(len(pf2D.xbin_labels)) * float(len(pf2D.ybin_labels)))
        # num_position_states = flat_position_size
        print(f'{num_position_states = }')
        binned_x = pf2D.filtered_pos_df['binned_x'].to_numpy()
        binned_y = pf2D.filtered_pos_df['binned_y'].to_numpy()

        binned_x_indicies = binned_x - 1
        binned_y_indicies = binned_y - 1
        ## Reference: Method of getting all combinations from pyphoplacecellanalysis.General.Pipeline.Stages.ComputationFunctions.PlacefieldDensityAnalysisComputationFunctions.PlacefieldDensityAnalysisComputationFunctions._perform_placefield_overlap_computation
        ```python
            all_pairwise_neuron_IDs_combinations = np.array(list(itertools.combinations(computation_result.computed_data['pf2D_Decoder'].neuron_IDs, 2)))
            list_of_unit_pfs = [computation_result.computed_data['pf2D_Decoder'].pf.ratemap.normalized_tuning_curves[i,:,:] for i in computation_result.computed_data['pf2D_Decoder'].neuron_IDXs]
            all_pairwise_pfs_combinations = np.array(list(itertools.combinations(list_of_unit_pfs, 2)))
            # np.shape(all_pairwise_pfs_combinations) # (903, 2, 63, 63)
            all_pairwise_overlaps = np.squeeze(np.prod(all_pairwise_pfs_combinations, axis=1)) # multiply over the dimension containing '2' (multiply each pair of pfs).
        ```
        for a_row in pf2D.filtered_pos_df[['binned_x', 'binned_y']].itertuples():
            x_bin_idx, y_bin_idx = (a_row.binned_x-1), (a_row.binned_y-1)
            print(f'')

        # binned_x_transition_matrix = transition_matrix(deepcopy(binned_x))
        binned_x_transition_matrix = transition_matrix(deepcopy(binned_x_indicies), markov_order=1)
        binned_x_transition_matrix_higher_order_list = [binned_x_transition_matrix, transition_matrix(deepcopy(binned_x_indicies), markov_order=2), transition_matrix(deepcopy(binned_x_indicies), markov_order=3)]

    """
    ...

